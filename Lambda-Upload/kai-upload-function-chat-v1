import boto3
import json
import openai
from openai import OpenAI

# -------------------------------
# ğŸ”‘ Secrets + Clients
# -------------------------------
def get_openai_key():
    secret_name = "openai/api-key"
    client = boto3.client("secretsmanager")
    response = client.get_secret_value(SecretId=secret_name)
    return json.loads(response["SecretString"])["OPENAI_API_KEY"]

openai.api_key = get_openai_key()
s3 = boto3.client("s3")
ddb = boto3.client("dynamodb")

# -------------------------------
# ğŸ§  GPT Summariser
# -------------------------------
def call_gpt_extract(message):
    system_prompt = """
    You are a text parser that extracts structured information about uploaded files.
    Always return valid JSON with:
      - gpt_title
      - gpt_tags (list)
      - gpt_summary
    """
    try:
        client = OpenAI(api_key=openai.api_key)
        response = client.chat.completions.create(
            model="gpt-4o-mini",
            messages=[
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": message}
            ],
            temperature=0.2,
            max_tokens=200
        )
        result_text = response.choices[0].message.content
        return json.loads(result_text)
    except Exception as e:
        print("âš ï¸ GPT Error:", e)
        return {
            "gpt_title": "Untitled",
            "gpt_tags": ["unclassified"],
            "gpt_summary": f"GPT error: {str(e)}"
        }

# -------------------------------
# ğŸ§© Shared Logic
# -------------------------------
def process_and_save(bucket, key, meta):
    table_name = "kai-assistant-data"
    message = meta.get("message", "")

    if not message:
        return {"statusCode": 400, "body": "Missing 'message' metadata"}

    # 1ï¸âƒ£ GPT analysis
    gpt_result = call_gpt_extract(message)

    # 2ï¸âƒ£ DynamoDB Write
    try:
        item = {
            "user_id": {"S": meta.get("user", "unknown")},
            "file_id": {"S": meta.get("upload_id", key)},
            "original_name": {"S": meta.get("original_name", key)},
            "message": {"S": message},
            "tab": {"S": meta.get("tab", "chat")},
            "timestamp": {"S": meta.get("timestamp", "unknown")},
            "status": {"S": "processed"},
            "source": {"S": "lambda-gpt-processor"},
            "s3_path": {"S": f"s3://{bucket}/{key}"},
            "gpt_title": {"S": gpt_result.get("gpt_title", "Untitled")},
            "gpt_tags": {"S": json.dumps(gpt_result.get("gpt_tags", []))},
            "gpt_summary": {"S": gpt_result.get("gpt_summary", "")},
            "gpt_result_raw": {"S": json.dumps(gpt_result)}
        }

        ddb.put_item(TableName=table_name, Item=item)
        print(f"âœ… Saved GPT result to DynamoDB for {key}")

    except Exception as e:
        print("âš ï¸ DynamoDB Write Error:", e)

    # 3ï¸âƒ£ Tag S3 object
    try:
        s3.put_object_tagging(
            Bucket=bucket,
            Key=key,
            Tagging={
                'TagSet': [
                    {'Key': 'Status', 'Value': 'processed'},
                    {'Key': 'Tab', 'Value': meta.get('tab', 'chat')},
                    {'Key': 'GPT_Tags', 'Value': '-'.join(
                        [t.replace(" ", "_") for t in gpt_result.get("gpt_tags", [])]
                    )[:128]}
                ]
            }
        )
        print(f"ğŸ·ï¸ Tagged S3 object as processed: {key}")

    except Exception as e:
        print("âš ï¸ Tagging Error:", e)

    return {
        "statusCode": 200,
        "body": json.dumps({
            "route": meta.get("tab", "chat"),
            "file": key,
            "gpt_result": gpt_result
        })
    }

# -------------------------------
# ğŸ§© Route Handlers
# -------------------------------
def handle_chat(bucket, key, meta):
    print("ğŸ’¬ Handling chat upload...")
    return process_and_save(bucket, key, meta)

def handle_taxclaim(bucket, key, meta):
    print("ğŸ’¼ Handling tax claim upload...")
    return process_and_save(bucket, key, meta)

# -------------------------------
# ğŸš€ Main Handler (Final Version)
# -------------------------------
def lambda_handler(event, context):
    # raise Exception("ğŸ’¥ Simulated crash for DLQ test")

    print("ğŸ“¥ Incoming event:", json.dumps(event, indent=2))

    # --- Helper function to extract bucket/key safely ---
    def extract_s3_details(record):
        try:
            # Direct S3 trigger
            if record.get("eventSource") == "aws:s3":
                return record["s3"]["bucket"]["name"], record["s3"]["object"]["key"]

            # SNS-wrapped S3 trigger
            if record.get("EventSource") == "aws:sns":
                sns_message = json.loads(record["Sns"]["Message"])
                inner = sns_message["Records"][0]
                return inner["s3"]["bucket"]["name"], inner["s3"]["object"]["key"]

            # SQS-wrapped S3 trigger
            if record.get("eventSource") == "aws:sqs":
                body = json.loads(record["body"])
                inner = body["Records"][0]
                return inner["s3"]["bucket"]["name"], inner["s3"]["object"]["key"]

        except Exception as e:
            print(f"âš ï¸ Failed to extract S3 details: {e}")
        return None, None

    # --- Handle manual test event (no Records) ---
    if "Records" not in event:
        print("âš™ï¸ Manual mode triggered (no Records in event).")
        route = event.get("tab", "chat")
        return {
            "statusCode": 200,
            "body": json.dumps({"message": f"Manual test route confirmed: {route}"})
        }

    # --- Process each record ---
    for record in event["Records"]:
        bucket, key = extract_s3_details(record)
        if not bucket or not key:
            print("âš ï¸ No S3 details found in record â€” skipping.")
            continue

        print(f"ğŸ“¦ File detected: s3://{bucket}/{key}")

        try:
            head = s3.head_object(Bucket=bucket, Key=key)
            meta = head.get("Metadata", {})
            route = meta.get("tab", "chat")

            print(f"ğŸ§¾ Metadata: {json.dumps(meta, indent=2)}")
            print(f"ğŸ”€ Route selected: {route}")

            if route == "taxclaim":
                result = handle_taxclaim(bucket, key, meta)
            else:
                result = handle_chat(bucket, key, meta)

            print(f"âœ… Processing complete for: {key}")
            return result

        except Exception as e:
            print(f"âŒ Error handling file {key}: {e}")

    return {"statusCode": 200, "body": json.dumps({"message": "All records processed."})}
